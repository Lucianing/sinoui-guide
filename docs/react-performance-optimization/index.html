<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>React性能优化 · sinoui开发指南</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;blockquote&gt;
&lt;p&gt;注意：此文档还在修改状态。&lt;/p&gt;
&lt;/blockquote&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="React性能优化 · sinoui开发指南"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sinoui.github.io/sinoui-guide/"/><meta property="og:description" content="&lt;blockquote&gt;
&lt;p&gt;注意：此文档还在修改状态。&lt;/p&gt;
&lt;/blockquote&gt;
"/><meta property="og:image" content="https://sinoui.github.io/sinoui-guide/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sinoui.github.io/sinoui-guide/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/sinoui-guide/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="stylesheet" href="/sinoui-guide/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/sinoui-guide/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/sinoui-guide/css/prism.css"/><link rel="stylesheet" href="/sinoui-guide/css/main.css"/><script src="/sinoui-guide/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/sinoui-guide/"><h2 class="headerTitle">sinoui开发指南</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/sinoui-guide/docs/react-index" target="_self">基础知识</a></li><li class=""><a href="/sinoui-guide/docs/app-dev-index" target="_self">应用开发指南</a></li><li class=""><a href="/sinoui-guide/docs/tools-index" target="_self">前端资源</a></li><li class=""><a href="https://github.com/sinoui/sinoui-guide" target="_self">GitHub</a></li><li class=""><a href="/sinoui-guide/help" target="_self">Help</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>React进阶</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">React<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-index">教程开篇</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-getting-started">React入门</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-jsx">JSX概述</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-props-state">组件属性和状态</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-hook">React Hook</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-lifting-state-up">状态提升</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-fetch-data">加载数据</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-ref">ref</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">TypeScript/ES6<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/es6-tutorial">ES6简明教程</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/ts-tutorial">TypeScript简明教程</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-ts-tutorial">在React中使用TypeScript</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/ts-advanced-types">TypeScript高级类型</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">样式<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/styled-components-guide">styled-components</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-animation">动画</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">状态管理<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-context">React Context</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/redux-getting-started">Redux入门</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/context-and-hook">使用Context和hook做状态管理</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-redux">在React中使用redux做状态管理</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/immutable-getting-started">不可变数据</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">React进阶<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/sinoui-guide/docs/react-performance-optimization">React性能优化</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">React性能优化</h1></header><article><div><span><blockquote>
<p>注意：此文档还在修改状态。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="组件缓存"></a><a href="#组件缓存" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>组件缓存</h2>
<p>由于 React 并不知道在父组件中的更新是否会影响到其子代，所以 React 会在父组件更新时，将其所有子代也重绘，这会导致很大的性能消耗。为了减少这种不必要的性能损耗，我们可以使用<strong>缓存</strong>的方式处理子组件。这样当<code>props</code>浅层比较的结果相同时，父组件发生变化时，React 会去缓存中重用子组件先前的渲染结果，而不是重新渲染子组件。</p>
<blockquote>
<p>使用<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">React.memo()</a>做组件缓存。</p>
</blockquote>
<p>下面我们来对比看下使用缓存前后对性能的影响：</p>
<p>使用前：</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

interface Props {
  <span class="hljs-attr">title</span>: string;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [, setCount] = useState(<span class="hljs-number">0</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// 每隔一秒钟重绘一次组件</span>
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      setCount(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> prev + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">1000</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;Child title="child1" /&gt;
      &lt;Child title="child2" /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Parent /&gt;, document.getElementById('root'));
</code></pre>
<p><code>Parent</code>组件每隔一秒钟发生一次状态变更，两个<code>Child</code>组件也会发生重绘，如下面的 React 渲染火焰图所示（绿色方格代表发生了重绘）：</p>
<p><img src="./assets/images/memo_before.png" alt="memo_before"></p>
<p>为了避免不必要的渲染，我们可以对上述示例稍加调整：</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

interface Props {
  <span class="hljs-attr">title</span>: string;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">const</span> MemoChild = React.memo(Child);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [, setCount] = useState(<span class="hljs-number">0</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// 每隔一秒钟重绘一次组件</span>
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      setCount(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> prev + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">1000</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;MemoChild title="child1" /&gt;
      &lt;MemoChild title="child2" /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Parent /&gt;, document.getElementById('root'));
</code></pre>
<p>这里我们使用<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">React.memo</a>做了组件缓存，因此在<code>Parent</code>组件状态发生变化时，两个<code>Child</code>组件因为属性没有发生变化，React 会从缓存中取其上次的渲染结果，而不是重新传染。渲染效果如下（火焰图中的两个<code>Memo(Child)</code>小方格都是灰色的，代表未发生重绘）：</p>
<p><img src="./assets/images/memo_after.png" alt="memo_after"></p>
<h3><a class="anchor" aria-hidden="true" id="props-浅层比较"></a><a href="#props-浅层比较" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>props</code>浅层比较</h3>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> objA = {
  <span class="hljs-attr">a</span>: <span class="hljs-string">'1'</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">'2'</span>,
};

<span class="hljs-keyword">const</span> objB = {
  <span class="hljs-attr">a</span>: <span class="hljs-string">'1'</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">'2'</span>,
};

<span class="hljs-built_in">Object</span>.keys(objA).every(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> objA[key] === objB[key]); <span class="hljs-comment">// true</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="函数属性"></a><a href="#函数属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>函数属性</h4>
<h5><a class="anchor" aria-hidden="true" id="动态函数属性"></a><a href="#动态函数属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>动态函数属性</h5>
<p>这里我们首先来看一个示例：</p>
<pre><code class="hljs css language-tsx">import React, { useState, ChangeEvent } from 'react';
import ReactDOM from 'react-dom';

<span class="hljs-keyword">function</span> <span class="hljs-constructor">Input(<span class="hljs-params">props</span>: <span class="hljs-params">any</span>)</span> {
  return &lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> value={props.value} onChange={props.onChange} /&gt;;
}

const TextInput = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>memo(Input);

<span class="hljs-keyword">function</span> <span class="hljs-constructor">Demo()</span> {
  const <span class="hljs-literal">[<span class="hljs-identifier">value1</span>, <span class="hljs-identifier">setValue1</span>]</span> = use<span class="hljs-constructor">State('')</span>;
  const <span class="hljs-literal">[<span class="hljs-identifier">value2</span>, <span class="hljs-identifier">setValue2</span>]</span> = use<span class="hljs-constructor">State('')</span>;

  const onChangeValue1 =<span class="hljs-function"> (<span class="hljs-params">event</span>: C<span class="hljs-params">hangeEvent</span>&lt;HTMLI<span class="hljs-params">nputElement</span>&gt;) =&gt;</span> {
    set<span class="hljs-constructor">Value1(<span class="hljs-params">event</span>.<span class="hljs-params">target</span>.<span class="hljs-params">value</span>)</span>;
  };

  const onChangeValue2 =<span class="hljs-function"> (<span class="hljs-params">event</span>: C<span class="hljs-params">hangeEvent</span>&lt;HTMLI<span class="hljs-params">nputElement</span>&gt;) =&gt;</span> {
    set<span class="hljs-constructor">Value2(<span class="hljs-params">event</span>.<span class="hljs-params">target</span>.<span class="hljs-params">value</span>)</span>;
  };

  return (
    &lt;div&gt;
      &lt;TextInput value={value1} onChange={onChangeValue1} /&gt;
      &lt;TextInput value={value2} onChange={onChangeValue2} /&gt;
    &lt;/div&gt;
  );
}

<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReactDOM</span>.</span></span>render(&lt;Demo /&gt;, document.get<span class="hljs-constructor">ElementById('<span class="hljs-params">root</span>')</span>);
</code></pre>
<p>思考一个问题：此时如果改变第二个<code>TextInput</code>值，第一个<code>TextInput</code>会重新渲染吗？</p>
<p>一定会的，看下渲染结果：</p>
<p><img src="./assets/images/use_callback_before.png" alt="use_callback_before"></p>
<p>可能你会有疑问：不是已经用了<code>React.memo</code>缓存了吗？为什么还会重新渲染呢？</p>
<p>其实这是因为<code>TextInput</code>的<code>onChange</code>属性，这是一个用来监听值变化的回调函数，输入框的值发生改变时，<code>Demo</code>组件会重绘，而此时<code>onChange</code>属性会指向一个新的方法，此时<code>TextInput</code>的属性浅层比较会返回<code>false</code>,组件就会重新渲染。</p>
<p>解决上述问题有两种方式：</p>
<p>方式一：使用<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback">React.useCallback</a>缓存处理值变化的方法</p>
<pre><code class="hljs css language-tsx">import React, { useState, ChangeEvent, useCallback } from 'react';
import ReactDOM from 'react-dom';

<span class="hljs-keyword">function</span> <span class="hljs-constructor">Input(<span class="hljs-params">props</span>: <span class="hljs-params">any</span>)</span> {
  return &lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> value={props.value} onChange={props.onChange} /&gt;;
}

const TextInput = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>memo(Input);

<span class="hljs-keyword">function</span> <span class="hljs-constructor">Demo()</span> {
  const <span class="hljs-literal">[<span class="hljs-identifier">value1</span>, <span class="hljs-identifier">setValue1</span>]</span> = use<span class="hljs-constructor">State('')</span>;
  const <span class="hljs-literal">[<span class="hljs-identifier">value2</span>, <span class="hljs-identifier">setValue2</span>]</span> = use<span class="hljs-constructor">State('')</span>;

  const onChangeValue1 = use<span class="hljs-constructor">Callback((<span class="hljs-params">event</span>: ChangeEvent&lt;HTMLInputElement&gt;)</span> =&gt; {
    set<span class="hljs-constructor">Value1(<span class="hljs-params">event</span>.<span class="hljs-params">target</span>.<span class="hljs-params">value</span>)</span>;
  }, <span class="hljs-literal">[]</span>);

  const onChangeValue2 = use<span class="hljs-constructor">Callback((<span class="hljs-params">event</span>: ChangeEvent&lt;HTMLInputElement&gt;)</span> =&gt; {
    set<span class="hljs-constructor">Value2(<span class="hljs-params">event</span>.<span class="hljs-params">target</span>.<span class="hljs-params">value</span>)</span>;
  }, <span class="hljs-literal">[]</span>);

  return (
    &lt;div&gt;
      &lt;TextInput value={value1} onChange={onChangeValue1} /&gt;
      &lt;TextInput value={value2} onChange={onChangeValue2} /&gt;
    &lt;/div&gt;
  );
}

<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReactDOM</span>.</span></span>render(&lt;Demo /&gt;, document.get<span class="hljs-constructor">ElementById('<span class="hljs-params">root</span>')</span>);
</code></pre>
<p>上述示例中,<code>useCallback</code>的依赖项数组为<code>[]</code>，所以，<code>onChangeValue1</code>与<code>onChangeValue2</code>这两个方法只会在组件初始化时创建一次，后续组件值发生改变时，会直接使用它的<code>memoized</code>版本。因此当其中一个<code>TextInput</code>的值发生改变时，另一个<code>TextInput</code>组件的属性满足浅层比较，React 会从缓存读取其上次渲染结果，而非重新渲染。</p>
<p><img src="./assets/images/use_callback_after.png" alt="use_callback_after"></p>
<p>方式二：使用<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer">React.useReducer</a>处理值变化</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> React, { ChangeEvent, useReducer } from <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM from <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> produce from <span class="hljs-string">'immer'</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-keyword">Action</span> {
  <span class="hljs-keyword">type</span>: string;
  payload: <span class="hljs-built_in">any</span>;
}

<span class="hljs-keyword">interface</span> State {
  [<span class="hljs-keyword">name</span>: string]: <span class="hljs-built_in">any</span>;
}

const reducer = produce((state: State, <span class="hljs-keyword">action</span>: <span class="hljs-keyword">Action</span>) =&gt; {
  switch (<span class="hljs-keyword">action</span>.<span class="hljs-keyword">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'CHANGE_VALUE'</span>:
      state[<span class="hljs-keyword">action</span>.payload.<span class="hljs-keyword">name</span>] = <span class="hljs-keyword">action</span>.payload.<span class="hljs-keyword">value</span>;
      <span class="hljs-keyword">return</span> state;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
});

<span class="hljs-function"><span class="hljs-keyword">function</span></span> Input(props: <span class="hljs-built_in">any</span>) {
  const onChangeValue = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    props.dispatch({
      <span class="hljs-keyword">type</span>: <span class="hljs-string">'CHANGE_VALUE'</span>,
      payload: { <span class="hljs-keyword">name</span>: props.<span class="hljs-keyword">name</span>, <span class="hljs-keyword">value</span>: event.<span class="hljs-keyword">target</span>.<span class="hljs-keyword">value</span> },
    });
  };
  <span class="hljs-keyword">return</span> &lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-keyword">value</span>={props.<span class="hljs-keyword">value</span>} onChange={onChangeValue} /&gt;;
}

const TextInput = React.memo(Input);

<span class="hljs-function"><span class="hljs-keyword">function</span></span> Demo() {
  const [state, dispatch] = useReducer(reducer, {});

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;TextInput <span class="hljs-keyword">value</span>={state.value1} <span class="hljs-keyword">name</span>=<span class="hljs-string">"value1"</span> dispatch={dispatch} /&gt;
      &lt;TextInput <span class="hljs-keyword">value</span>={state.value2} <span class="hljs-keyword">name</span>=<span class="hljs-string">"value2"</span> dispatch={dispatch} /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Demo /&gt;, document.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<p>上述示例中，我们向子组件传递<code>dispatch</code>而不是回调函数。这样当第一个<code>TextInput</code>值发生改变时，第二个<code>TextInput</code>组件的属性并没有发生改变，因此其不会重新渲染。</p>
<p><img src="./assets/images/usereducer_after.png" alt="usereducer_after"></p>
<h5><a class="anchor" aria-hidden="true" id="静态函数属性"></a><a href="#静态函数属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>静态函数属性</h5>
<p>当组件属性为一个静态函数时，为了减少不必要的渲染，我们可以将函数提升到组件外部，下面我们将通过两个实例对比提升前和提升后的影响。</p>
<p>组件内部处理：</p>
<pre><code class="hljs css language-tsx">import React, { useState, ChangeEvent, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
import ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function">function <span class="hljs-title">Input</span>(<span class="hljs-params">props: any</span>)</span> {
  <span class="hljs-keyword">const</span> error = props.validate(props.<span class="hljs-keyword">value</span>);
  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;input type=<span class="hljs-string">"text"</span> <span class="hljs-keyword">value</span>={props.<span class="hljs-keyword">value</span>} onChange={props.onChange} /&gt;
      &lt;p style={{ color: <span class="hljs-string">'red'</span> }}&gt;{error}&lt;/p&gt;
    &lt;/&gt;
  );
}

<span class="hljs-keyword">const</span> TextInput = React.memo(Input);

<span class="hljs-function">function <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">const</span> [value1, setValue1] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> [value2, setValue2] = useState(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> onChangeValue1 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue1(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);

  <span class="hljs-keyword">const</span> onChangeValue2 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue2(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);
    
  <span class="hljs-keyword">const</span> validate = (<span class="hljs-keyword">value</span>: any) =&gt; {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">value</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'必填'</span>;
    }
  };

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;TextInput <span class="hljs-keyword">value</span>={value1} onChange={onChangeValue1} validate={validate} /&gt;
      &lt;TextInput <span class="hljs-keyword">value</span>={value2} onChange={onChangeValue2} validate={validate} /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Demo /&gt;, document.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<p>此时只要任意一个输入框的值发生改变，父组件就会重新渲染，创建新的validate函数传给子组件，这样就破坏了属性浅层比较，子组件会重新渲染。</p>
<p><img src="./assets/images/static_fn_props_before.png" alt="static_fn_props_before"></p>
<p>我们对上述示例稍加调整，将<code>validate</code>提升至组件外部：</p>
<pre><code class="hljs css language-tsx">import React, { useState, ChangeEvent, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
import ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function">function <span class="hljs-title">Input</span>(<span class="hljs-params">props: any</span>)</span> {
  <span class="hljs-keyword">const</span> error = props.validate(props.<span class="hljs-keyword">value</span>);
  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;input type=<span class="hljs-string">"text"</span> <span class="hljs-keyword">value</span>={props.<span class="hljs-keyword">value</span>} onChange={props.onChange} /&gt;
      &lt;p style={{ color: <span class="hljs-string">'red'</span> }}&gt;{error}&lt;/p&gt;
    &lt;/&gt;
  );
}

<span class="hljs-keyword">const</span> TextInput = React.memo(Input);

<span class="hljs-function">function <span class="hljs-title">validate</span>(<span class="hljs-params"><span class="hljs-keyword">value</span>: any</span>)</span> {
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">value</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'必填'</span>;
  }
}

<span class="hljs-function">function <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">const</span> [value1, setValue1] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> [value2, setValue2] = useState(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> onChangeValue1 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue1(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);

  <span class="hljs-keyword">const</span> onChangeValue2 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue2(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;TextInput <span class="hljs-keyword">value</span>={value1} onChange={onChangeValue1} validate={validate} /&gt;
      &lt;TextInput <span class="hljs-keyword">value</span>={value2} onChange={onChangeValue2} validate={validate} /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Demo /&gt;, document.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<p>我们来看下渲染结果的分析图：</p>
<p><img src="./assets/images/static_fn_props_after.png" alt="static_fn_props_after"></p>
<p>从火焰图中我们可以看出，当我们改变第一个<code>TextInput</code>值时，第二个<code>TextInput</code>并没有重新渲染。这是因为当我们把校验函数提升到组件外部，即<code>全局作用域</code>中，所以无论<code>Demo</code>内部如何变化，<code>validate</code>都不会发生改变，这样第二个<code>TextInput</code>组件的属性满足浅层比较，因此不会重新渲染。</p>
<h4><a class="anchor" aria-hidden="true" id="数组-对象属性"></a><a href="#数组-对象属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数组、对象属性</h4>
<h5><a class="anchor" aria-hidden="true" id="动态计算出的对象属性"></a><a href="#动态计算出的对象属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>动态计算出的对象属性</h5>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserInfo</span>(<span class="hljs-params">props: any</span>) </span>{
  <span class="hljs-keyword">const</span> { userName, age, duty, fav, birthday } = props.userInfo;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>姓名：{userName}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>爱好：{fav}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>职务：{duty}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>出生年份：{birthday}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">const</span> User = React.memo(UserInfo);

<span class="hljs-keyword">const</span> data = {
  <span class="hljs-attr">userName</span>: <span class="hljs-string">'张三'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>,
  <span class="hljs-attr">fav</span>: <span class="hljs-string">'篮球、排球'</span>,
  <span class="hljs-attr">duty</span>: <span class="hljs-string">'处员'</span>,
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> currentYear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();

  <span class="hljs-keyword">const</span> [, setCount] = useState(<span class="hljs-number">0</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// 每隔一秒钟重绘一次组件</span>
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      setCount(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> prev + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">1000</span>);
  }, []);

  <span class="hljs-keyword">const</span> userInfo = {
    ...data,
    <span class="hljs-attr">age</span>: <span class="hljs-string">`<span class="hljs-subst">${data.age}</span>岁`</span>,
    <span class="hljs-attr">birthday</span>: currentYear - data.age,
  };
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">userInfo</span>=<span class="hljs-string">{userInfo}</span> /&gt;</span>;
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">Demo</span> /&gt;</span>, document.getElementById('root'));
</span></code></pre>
<p>我们来思考一个问题：每次<code>Demo</code>组件重绘时，<code>UserInfo</code>会不会重绘？</p>
<p>很显然，答案是会的，因为<code>Demo</code>每次重绘，都会定义一个新的<code>userInfo</code>对象传给<code>UserInfo</code>组件，不满足其属性浅层比较，因此<code>UserInfo</code>会发生重绘。</p>
<p><img src="./assets/images/object_props_before.png" alt="object_props_before"></p>
<p>这种情况很容易处理，我们只需要使用<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo">React.useMemo</a>缓存一下<code>userInfo</code>这个对象属性即可：</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> React, { useState, useEffect, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserInfo</span>(<span class="hljs-params">props: any</span>) </span>{
  <span class="hljs-keyword">const</span> { userName, age, duty, fav, birthday } = props.userInfo;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>姓名：{userName}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>爱好：{fav}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>职务：{duty}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>出生年份：{birthday}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">const</span> User = React.memo(UserInfo);

<span class="hljs-keyword">const</span> data = {
  <span class="hljs-attr">userName</span>: <span class="hljs-string">'张三'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>,
  <span class="hljs-attr">fav</span>: <span class="hljs-string">'篮球、排球'</span>,
  <span class="hljs-attr">duty</span>: <span class="hljs-string">'处员'</span>,
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> currentYear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();

  <span class="hljs-keyword">const</span> [, setCount] = useState(<span class="hljs-number">0</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// 每隔一秒钟重绘一次组件</span>
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      setCount(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> prev + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">1000</span>);
  }, []);

  <span class="hljs-keyword">const</span> userInfo = useMemo(
    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      ...data,
      <span class="hljs-attr">age</span>: <span class="hljs-string">`<span class="hljs-subst">${data.age}</span>岁`</span>,
      <span class="hljs-attr">birthday</span>: currentYear - data.age,
    }),
    [data, currentYear],
  );
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">userInfo</span>=<span class="hljs-string">{userInfo}</span> /&gt;</span>;
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">Demo</span> /&gt;</span>, document.getElementById('root'));
</span></code></pre>
<p>此时，在父组件发生重绘时，子组件是不会重新渲染的，原因是因为每次重绘，<code>currentYear</code>和<code>data</code>都没发生改变，<code>userInfo</code>一直都是第一次渲染时定义的那个，不会发生改变，这样就满足了<code>UserInfo</code>组件的浅层比较，因此不会重新渲染。</p>
<p><img src="./assets/images/object_props_after.png" alt="object_props_after"></p>
<h5><a class="anchor" aria-hidden="true" id="静态对象属性"></a><a href="#静态对象属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>静态对象属性</h5>
<p>当组件属性为静态对象时,我们可以将其提升到组件外部的全局作用域，以此来满足子组件属性的浅层比较。这里我们给输入框添加label，并指定其样式，通过对比下面两个示例，看下静态对象属性对组件渲染的影响：</p>
<p>直接传递静态对象属性</p>
<pre><code class="hljs css language-tsx">import React, { useState, ChangeEvent, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
import ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function">function <span class="hljs-title">Input</span>(<span class="hljs-params">props: any</span>)</span> {
  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;label style={props.labelStyle}&gt;{props.label}&lt;/label&gt;
      &lt;input type=<span class="hljs-string">"text"</span> <span class="hljs-keyword">value</span>={props.<span class="hljs-keyword">value</span>} onChange={props.onChange} /&gt;
    &lt;/&gt;
  );
}

<span class="hljs-keyword">const</span> TextInput = React.memo(Input);

<span class="hljs-function">function <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">const</span> [value1, setValue1] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> [value2, setValue2] = useState(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> onChangeValue1 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue1(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);

  <span class="hljs-keyword">const</span> onChangeValue2 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue2(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;TextInput
        labelStyle={{ color: <span class="hljs-string">'blue'</span> }}
        label=<span class="hljs-string">"用户名"</span>
        <span class="hljs-keyword">value</span>={value1}
        onChange={onChangeValue1}
      /&gt;
      &lt;TextInput
        labelStyle={{ color: <span class="hljs-string">'blue'</span> }}
        label=<span class="hljs-string">"密码"</span>
        <span class="hljs-keyword">value</span>={value2}
        onChange={onChangeValue2}
      /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Demo /&gt;, document.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<p>改变一个输入框的值，由于<code>labelStyle</code>为对象属性，不满足<code>TextInput</code>属性的浅层比较，因此组件会重新渲染：</p>
<p><img src="./assets/images/static_object_before.png" alt="image"></p>
<p>我们尝试将上述示例中的<code>lableStyle</code>提升至<code>Demo</code>组件外部的全局作用域中，再看下效果：</p>
<pre><code class="hljs css language-tsx">import React, { useState, ChangeEvent, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
import ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function">function <span class="hljs-title">Input</span>(<span class="hljs-params">props: any</span>)</span> {
  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;label style={props.labelStyle}&gt;{props.label}&lt;/label&gt;
      &lt;input type=<span class="hljs-string">"text"</span> <span class="hljs-keyword">value</span>={props.<span class="hljs-keyword">value</span>} onChange={props.onChange} /&gt;
    &lt;/&gt;
  );
}

<span class="hljs-keyword">const</span> TextInput = React.memo(Input);

<span class="hljs-keyword">const</span> labelStyle = { color: <span class="hljs-string">'blue'</span> };

<span class="hljs-function">function <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">const</span> [value1, setValue1] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> [value2, setValue2] = useState(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> onChangeValue1 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue1(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);

  <span class="hljs-keyword">const</span> onChangeValue2 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue2(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;TextInput
        labelStyle={labelStyle}
        label=<span class="hljs-string">"用户名"</span>
        <span class="hljs-keyword">value</span>={value1}
        onChange={onChangeValue1}
      /&gt;
      &lt;TextInput
        labelStyle={labelStyle}
        label=<span class="hljs-string">"密码"</span>
        <span class="hljs-keyword">value</span>={value2}
        onChange={onChangeValue2}
      /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Demo /&gt;, document.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<p>将<code>labelStyle</code>提升至全局作用域，这样每次组件内部发生变化时，<code>labelStyle</code>并没有变，满足<code>TextInput</code>属性的浅层比较，因此在第一个<code>TextInput</code>值发生改变时，父组件会从缓存中取第二个<code>TextInput</code>的渲染结果，而不是重新渲染。</p>
<p>火焰图：</p>
<p><img src="./assets/images/static_object_after.png" alt="static_object_after"></p>
<h4><a class="anchor" aria-hidden="true" id="children属性"></a><a href="#children属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>children属性</h4>
<h5><a class="anchor" aria-hidden="true" id="静态-jsx-的优化"></a><a href="#静态-jsx-的优化" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>静态<code>JSX</code>的优化</h5>
<p>静态<code>JSX</code>优化，可以将静态的<code>Jsx</code>部分提升到组件外部定义：</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChildInner</span>(<span class="hljs-params">props: any</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{props.children}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}

<span class="hljs-keyword">const</span> Child = React.memo(ChildInner);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> childs = (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span>这是文本<span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
  return <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{childs}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">Parent</span> /&gt;</span>, document.getElementById('root'));
</span></code></pre>
<p>在React应用中我们无需手动处理，可以借助<a href="https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements">react-constant-elements工具完成</a>，需要注意的是场此插件只作用于生产环境。</p>
<h2><a class="anchor" aria-hidden="true" id="使用工具度量react组件性能"></a><a href="#使用工具度量react组件性能" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用工具度量React组件性能</h2>
<h3><a class="anchor" aria-hidden="true" id="react-devtools"></a><a href="#react-devtools" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>react-devtools</h3>
<p>这里我们主要是用react-devtools的火焰图来做性能分析。</p>
<p>我们以一个具体示例来说明：</p>
<pre><code class="hljs css language-tsx">import React, { useState, ChangeEvent, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
import ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function">function <span class="hljs-title">Input</span>(<span class="hljs-params">props: any</span>)</span> {
  <span class="hljs-keyword">const</span> error = props.validate(props.<span class="hljs-keyword">value</span>);
  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;input type=<span class="hljs-string">"text"</span> <span class="hljs-keyword">value</span>={props.<span class="hljs-keyword">value</span>} onChange={props.onChange} /&gt;
      &lt;p style={{ color: <span class="hljs-string">'red'</span> }}&gt;{error}&lt;/p&gt;
    &lt;/&gt;
  );
}

<span class="hljs-keyword">const</span> TextInput = React.memo(Input);

<span class="hljs-function">function <span class="hljs-title">validate</span>(<span class="hljs-params"><span class="hljs-keyword">value</span>: any</span>)</span> {
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">value</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'必填'</span>;
  }
}

<span class="hljs-function">function <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">const</span> [value1, setValue1] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> [value2, setValue2] = useState(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> onChangeValue1 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue1(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);

  <span class="hljs-keyword">const</span> onChangeValue2 = useCallback((<span class="hljs-keyword">event</span>: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue2(<span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;TextInput <span class="hljs-keyword">value</span>={value1} onChange={onChangeValue1} validate={validate} /&gt;
      &lt;TextInput <span class="hljs-keyword">value</span>={value2} onChange={onChangeValue2} validate={validate} /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Demo /&gt;, document.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<p>react-devtools使用方式：</p>
<ul>
<li>运行上述示例</li>
<li>打开F12控制台，将页签切换至<code>React</code></li>
<li>将工具条从<code>Elements</code>切换至<code>Profilter</code></li>
<li>点击小圆点开始分析，改变值使组件重绘点击<code>stop</code>按钮，收集分析结果</li>
</ul>
<p><img src="./assets/images/fire_action.png" alt="fire_action"></p>
<p>分析结果如下：</p>
<p><img src="./assets/images/fire_result.jpg" alt="火焰图"></p>
<p>图中有三块区域：</p>
<ol>
<li>组件渲染次数</li>
<li>每次渲染时相关组件的渲染情况（灰色代表不渲染，绿色或黄色代表重新渲染）</li>
<li>渲染信息，包括组件的总渲染次数，渲染耗时，组件属性等信息</li>
</ol>
<p>从上图结果不难看出，当我们改变第一个输入框的值时，父组件发生重绘，此时第一个输入框也会重新渲染，第二个输入框组件则不会重新渲染。</p>
<h3><a class="anchor" aria-hidden="true" id="performance-分析"></a><a href="#performance-分析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>performance 分析</h3>
<p>这是 Chrome 浏览器自带的性能分析工具。</p>
<p>操作：</p>
<p>打开控制台，切换到<code>Performance</code>页签，确保 screenshots checkbox 是选中的，然后点击 controls，开始记录（windows 快捷键 shift + E），这时候 Devtools 就开始录制各种性能指标，你可以点击页面等进行各种操作，所有的操作都会被浏览器录制下来。录制期间， 可以点击 stop 进行快速操作结束录制，然后等待显示性能报告，stop 按钮位置如下图：</p>
<p><img src="./assets/images/performance-active.png" alt="分析过程"></p>
<p>分析结果如下：</p>
<p><img src="./assets/images/performance-result.png" alt="分析结果"></p>
<p>上图一共有三个区域：</p>
<ol>
<li>overview 总览图，高度概括随时间线的变动，包括 FPS，CPU，NET</li>
<li>火焰图，从不同的角度分析框选区域 。例如：Network，Frames, Interactions, Main 等</li>
<li>总结区域：精确到毫秒级的分析，以及按调用层级，事件分类的整理</li>
</ol>
<h4><a class="anchor" aria-hidden="true" id="overview"></a><a href="#overview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>overview</h4>
<p>Overview 窗格包含以下三个图表：</p>
<ol>
<li>FPS。每秒帧数。绿色竖线越高，FPS 越高。 FPS 图表上的红色块表示长时间帧，很可能会出现卡顿</li>
<li>CPU。 CPU 资源。此面积图指示消耗 CPU 资源的事件类型</li>
<li>NET。每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。 每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间）</li>
</ol>
<p>可以放大显示一部分记录，以便简化分析。使用 Overview 窗格可以放大显示一部分记录。 放大后，火焰图会自动缩放以匹配同一部分</p>
<h4><a class="anchor" aria-hidden="true" id="火焰图"></a><a href="#火焰图" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>火焰图</h4>
<p>在火焰图上看到一到三条垂直的虚线。蓝线代表 DOMContentLoaded 事件。 绿线代表首次绘制的时间。 红线代表 load 事件</p>
<p>在火焰图中选择事件时，Details 窗格会显示与事件相关的其他信息。</p>
<h4><a class="anchor" aria-hidden="true" id="总结区域"></a><a href="#总结区域" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结区域</h4>
<p>蓝色(Loading)：网络通信和 HTML 解析
黄色(Scripting)：JavaScript 执行
紫色(Rendering)：样式计算和布局，即重排
绿色(Painting)：重绘
灰色(other)：其它事件花费的时间
白色(Idle)：空闲时间</p>
<h3><a class="anchor" aria-hidden="true" id="react-perf-devtools"></a><a href="#react-perf-devtools" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>react perf devtools</h3>
<h2><a class="anchor" aria-hidden="true" id="class-组件的-shouldcomponentupdate"></a><a href="#class-组件的-shouldcomponentupdate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>class 组件的 shouldComponentUpdate</h2>
<p>使用<code>shouldComponentUpdate()</code>可以让 React 知道当前状态或属性的改变是否不影响组件的输出，默认返回 ture，返回 false 时不会重新渲染。</p>
<pre><code class="hljs css language-JS"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = {<span class="hljs-attr">count</span>: <span class="hljs-number">1</span>};
  }

  shouldComponentUpdate(nextProps, nextState) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.color !== nextProps.color) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.count !== nextState.count) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
        <span class="hljs-attr">color</span>=<span class="hljs-string">{this.props.color}</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> this.setState(state =&gt; ({count: state.count + 1}))}&gt;
        Count: {this.state.count}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    );
  }
}
</code></pre>
<p>上述示例中只有当<code>props.color</code>或者<code>state.count</code>值发生变化时，组件才会重新渲染。</p>
<p>如果更复杂一些的组件，我们可以使用类似“浅比较”的模式来检查 <code>props</code> 和 <code>state</code> 中所有的字段，以此来决定是否组件需要更新。React 已经提供了一位好帮手来帮你实现这种常见的模式 - 你只要继承 <code>React.PureComponent</code> 就行了。所以这段代码可以改成以下这种更简洁的形式：</p>
<pre><code class="hljs css language-jsx"><span class="token keyword">class</span> <span class="token class-name">CounterButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span>
        <span class="token attr-name">color</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>color<span class="token punctuation">}</span></span>
        <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span>
      <span class="token punctuation">></span></span>
        Count<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="减小视图大小"></a><a href="#减小视图大小" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减小视图大小</h2>
<blockquote>
<p>减小视图大小也是一个非常有用的优化手段。</p>
</blockquote>
<p>比如我们有一个数据非常多的长列表，如果我们一次性渲染，肯定会性能非常差，但是如果我们只渲染看得见的部分，性能就得到了极大的提升。</p>
<p>下面举一个通过<a href="https://react-window.now.sh">windowing</a>的例子说明一下：</p>
<pre><code class="hljs css language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> FixedSizeList <span class="token keyword">as</span> List <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-window'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">Row</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> index<span class="token punctuation">,</span> style <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>style<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>Row <span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">Example</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">List</span></span> <span class="token attr-name">height</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">150</span><span class="token punctuation">}</span></span> <span class="token attr-name">itemCount</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">1000</span><span class="token punctuation">}</span></span> <span class="token attr-name">itemSize</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">35</span><span class="token punctuation">}</span></span> <span class="token attr-name">width</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">300</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span>
    <span class="token punctuation">{</span>Row<span class="token punctuation">}</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">List</span></span><span class="token punctuation">></span></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>在<a href="https://codesandbox.io/s/github/bvaughn/react-window/tree/master/website/sandboxes/fixed-size-list-vertical">CodeSandBox</a>上看一下运行效果。</p>
<p>这个长列表有 1000 个数据项，但是一次性只渲染 10 条数据项。这个列表的性能就会非常好。</p>
<p>对于不可见的 UI 部分，我们都可以采用延迟渲染的技巧来减少视图大小，提升性能。</p>
<h2><a class="anchor" aria-hidden="true" id="状态更新合并"></a><a href="#状态更新合并" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>状态更新合并</h2>
<p>React 对状态更新做了一个优化：同时多次设置状态，不会引起多次重绘，而只会合并为一次重绘。当然这个优化是有前提的。我们来看两个例子。</p>
<p>例子 1：</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo1</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [A, setA] = useState();
  <span class="hljs-keyword">const</span> [B, setB] = useState();

  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setA(<span class="hljs-number">1</span>);
    setB(<span class="hljs-number">2</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>更新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {A} - {B}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo1</span> /&gt;</span>, document.getElementById('root'));
</span></code></pre>
<p>点击例子 1 中的按钮，它会分别更新<code>A</code>和<code>B</code>两个状态，但是却只重绘了一次<code>Demo1</code>组件：</p>
<p><img src="/sinoui-guide/docs/assets/images/perf-batch.png" alt="perf batch"></p>
<p>再看看例子 2：</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [A, setA] = useState();
  <span class="hljs-keyword">const</span> [B, setB] = useState();

  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      setA(<span class="hljs-number">1</span>);
      setB(<span class="hljs-number">2</span>);
    });
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>更新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {A} - {B}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo2</span> /&gt;</span>, document.getElementById('root'));
</span></code></pre>
<p>点击例子 2 中的按钮，你会发现<code>Demo2</code>组件重绘了两次：</p>
<p><img src="/sinoui-guide/docs/assets/images/perf-batch-break.png" alt="perf batch break"></p>
<p>分析例子 2 与例子 1 的代码不同：</p>
<pre><code class="hljs css language-diff">import ReactDOM from 'react-dom';
import React, { useState } from 'react';

function Demo2() {
  const [A, setA] = useState();
  const [B, setB] = useState();

  const handleClick = () =&gt; {
<span class="hljs-addition">+   setTimeout(() =&gt; {</span>
      setA(1);
      setB(2);
<span class="hljs-addition">+   });</span>
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handleClick}&gt;更新&lt;/button&gt;
      &lt;div&gt;
        {A} - {B}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Demo2 /&gt;, document.getElementById('root'));
</code></pre>
<p>最重要的区别是：</p>
<pre><code class="hljs css language-ts">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  setA(<span class="hljs-number">1</span>);
  setB(<span class="hljs-number">2</span>);
});
</code></pre>
<p>在<code>setTimeout()</code>中执行状态更新，每一次状态更新都会引起重绘，而不会合并为一次重绘。不仅仅是<code>setTimeout()</code>，还包括<code>setInterval()</code>、<code>Promise</code>、<code>web socket</code>、<code>ajax</code>、<code>Observable</code>等都是这样的。这是因为这些状态更新不是在 React Scheduler 中而是在其他环境中执行的。这里不深入展开对 React Scheduler 的分析，大家感兴趣的可以了解一下相关知识。</p>
<p>目前有两种方式解决：</p>
<p>方式一：使用<code>useReducer</code>：</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> React, { useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">
  state: { A?: number; B?: number },
  action: { type: <span class="hljs-string">'CHANGE'</span> },
</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'CHANGE'</span>:
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">A</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">B</span>: <span class="hljs-number">2</span>,
      };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo3</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, {});

  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'CHANGE'</span> });
    });
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>更新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {state.A} - {state.B}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo3</span> /&gt;</span>, document.getElementById('root'));
</span></code></pre>
<p>方式二：使用<code>ReactDOM.unstable_batchedUpdates()</code>：</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [A, setA] = useState();
  <span class="hljs-keyword">const</span> [B, setB] = useState();

  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      ReactDOM.unstable_batchedUpdates(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        setA(<span class="hljs-number">1</span>);
        setB(<span class="hljs-number">2</span>);
      });
    });
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>更新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {A} - {B}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo2</span> /&gt;</span>, document.getElementById('root'));
</span></code></pre>
<p><code>ReactDOM.unstable_batchedUpdates(fn)</code>会在 React Scheduler 上下文中执行<code>fn</code>函数，所以<code>setA(1)</code>和<code>setB(2)</code>就会得到 React Scheduler 的优化，只会引发一次重绘。</p>
<p>但是<code>ReactDOM.unstable_batchedUpdates()</code> API 还处于不稳定状态，而且是从<code>ReactDOM</code>中引出来的，就会有<code>React Native</code>的兼容性问题。建议使用<code>import { batch } from 'react-redux';</code>中的<code>batch</code>代替<code>ReactDOM.unstable_batchedUpdates</code>。</p>
<h2><a class="anchor" aria-hidden="true" id="参考资料"></a><a href="#参考资料" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考资料</h2>
<ul>
<li><a href="https://overreacted.io/zh-hans/react-as-a-ui-runtime">将 React 作为 UI 运行时</a></li>
<li><a href="https://www.beautiful.ai/deck/-LIw2oTJmrrwRqvsoYgD/Why-React-is-Not-Reactive">Why React is Not Reactive?</a></li>
<li><a href="https://github.com/acdlite/react-fiber-architecture">React Fiber Architecture</a></li>
<li><a href="https://github.com/facebook/react/issues/10231">[Question] Keep to single setState call?</a></li>
<li><a href="https://www.youtube.com/watch?v=aS41Y_eyNrU&amp;feature=youtu.be">SMOOSHCAST: React Fiber Deep Dive with Dan Abramov</a></li>
</ul>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2019-6-30 by tianyanqiu</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/sinoui-guide/docs/immutable-getting-started"><span class="arrow-prev">← </span><span>不可变数据</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#组件缓存">组件缓存</a><ul class="toc-headings"><li><a href="#props-浅层比较"><code>props</code>浅层比较</a></li></ul></li><li><a href="#使用工具度量react组件性能">使用工具度量React组件性能</a><ul class="toc-headings"><li><a href="#react-devtools">react-devtools</a></li><li><a href="#performance-分析">performance 分析</a></li><li><a href="#react-perf-devtools">react perf devtools</a></li></ul></li><li><a href="#class-组件的-shouldcomponentupdate">class 组件的 shouldComponentUpdate</a></li><li><a href="#减小视图大小">减小视图大小</a></li><li><a href="#状态更新合并">状态更新合并</a></li><li><a href="#参考资料">参考资料</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2019 sinosoft.com.cn</section></footer></div></body></html>