<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>基于 Jest 的单元测试 · sinoui开发指南</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;体验一下&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#体验一下&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;体验一下&lt;/h2&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="基于 Jest 的单元测试 · sinoui开发指南"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sinoui.github.io/sinoui-guide/"/><meta property="og:description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;体验一下&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#体验一下&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;体验一下&lt;/h2&gt;
"/><meta property="og:image" content="https://sinoui.github.io/sinoui-guide/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sinoui.github.io/sinoui-guide/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/sinoui-guide/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="stylesheet" href="/sinoui-guide/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/sinoui-guide/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/sinoui-guide/css/prism.css"/><link rel="stylesheet" href="/sinoui-guide/css/main.css"/><script src="/sinoui-guide/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/sinoui-guide/"><h2 class="headerTitle">sinoui开发指南</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/sinoui-guide/docs/react-index" target="_self">基础知识</a></li><li class=""><a href="/sinoui-guide/docs/app-dev-index" target="_self">应用开发指南</a></li><li class="siteNavGroupActive"><a href="/sinoui-guide/docs/tools-index" target="_self">前端资源</a></li><li class=""><a href="https://github.com/sinoui/sinoui-guide" target="_self">GitHub</a></li><li class=""><a href="/sinoui-guide/help" target="_self">Help</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>单元测试</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">方法论<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/optimized-for-change">应变而优</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/tdd-introduction">测试驱动开发介绍</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/semver">语义化版本 2.0</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">规范<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/doc-of-api-standard">接口相关API文档编写规范</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/git-standard">git提交注释规范</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">单元测试<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/sinoui-guide/docs/jest-introduction">基于 Jest 的单元测试</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-component-test-guide">测试React组件</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/react-hook-test">自定义react hook 测试</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/jest-debounce">jest 测试 debounce</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">工具篇<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/tools-index">开篇</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/github-pages-introduction">Github Pages</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/circleci-introduction">CircleCI</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/package-manage">包管理工具：npm、npx和yarn</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/npm-dependencies-and-version">npm依赖与版本号</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">语言篇<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/default-import-export-compatibility">默认导出、导入兼容性</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/ts-function-overloading">TypeScript中的重载函数</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/polyfill">polyfill</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/debounce-and-throttle-guide">节流和防抖</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Node.js<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/nodejs">Node.js文件操作</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/express-guide">Express入门</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">HTML5<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/calculate-video-duration">计算视频时长</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/calculate-md5">计算md5</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/prevent-backspace-navigation">防止按退格键页面返回</a></li><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/mouse-event">鼠标事件</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">动画<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/sinoui-guide/docs/javascript-simple-animation">基于 JavaScript 实现简单的动画</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">基于 Jest 的单元测试</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="体验一下"></a><a href="#体验一下" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>体验一下</h2>
<p>使用<a href="https://github.com/sinoui/ts-lib-scripts">ts-lib-scripts</a>创建一个 ts 项目：</p>
<pre><code class="hljs css language-shell">npx ts-lib-scripts create jest-tutorial
</code></pre>
<p>打开项目，你就会看到有两个文件：<code>src/index.ts</code>和<code>src/index.spec.ts</code>，内容分别是：</p>
<p><code>index.ts</code>:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.14</span>;

<span class="hljs-comment">/**
 * 求和
 *
 * @param a 相加的数字
 * @param b 相加的数字
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p><code>index.spec.ts</code>:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { sum } <span class="hljs-keyword">from</span> <span class="hljs-string">'./index'</span>;

it(<span class="hljs-string">'1 + 1 = 2'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  expect(sum(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">2</span>);
});
</code></pre>
<p>执行下面的命令行启动 jest 执行单元测试：</p>
<pre><code class="hljs css language-shell">yarn test
</code></pre>
<p>你将会看到下面的执行结果：</p>
<pre><code class="hljs">PASS  src/index.spec.ts
  √ 1 + 1 = 2 (3ms)

<span class="hljs-keyword">Test </span>Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
<span class="hljs-keyword">Time:</span>        2.587s
Ran all test suites.

Watch Usage: Press w to show more.
</code></pre>
<p><code>index.spec.ts</code>就是一个使用 Jest 编写的单元测试，核心内容是<code>expect(sum(1, 1)).toBe(2)</code>，也就是你期望个<code>sum()</code>两个参数<code>1</code>和<code>1</code>，它的返回结果是<code>2</code>。这个期望就是<code>sum()</code>这个函数的核心作用。</p>
<p>我们使用 jest 测试的是方法的作用——我们用单元测试代码来表达期望它能做什么事情。只要单元测试通过，说明被测试的代码也就符合我们的预期。</p>
<h2><a class="anchor" aria-hidden="true" id="核心概念"></a><a href="#核心概念" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>核心概念</h2>
<p>单元测试技术上来说，有几个必须掌握的核心概念，包括：匹配器（编写断言必备技能）、setup 和 teardown、模拟、测试异步代码。接下来 4 个篇章将一一道来。</p>
<h2><a class="anchor" aria-hidden="true" id="匹配器-matchers"></a><a href="#匹配器-matchers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>匹配器 Matchers</h2>
<p>我们可以使用匹配器验证值。如下所示：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'two plus two is four'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  expect(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>).toBe(<span class="hljs-number">4</span>);
});
</code></pre>
<p>这段代码的意图是期望<code>2 + 2</code>的结果是<code>4</code>。<code>2 + 2</code>与<code>4</code>之间的匹配器是<code>toBe</code>，表示这二者之间是相同的关系。</p>
<p><code>toBe</code>使用<code>Object.is</code>测试相等性。如果你需要验证对象的值是否相同，则可以使用<code>toEqual</code>：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'对象值相同'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> data = { one: <span class="hljs-number">1</span> };
  data[<span class="hljs-string">'two'</span>] = <span class="hljs-number">2</span>;
  expect(data).toEqual({ one: <span class="hljs-number">1</span>, two: <span class="hljs-number">2</span> });
});

test(<span class="hljs-string">'数组值相同'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
  items.push(<span class="hljs-number">5</span>);

  expect(items).toEqual([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
});
</code></pre>
<p>如果表示不匹配，可以在使用<code>not</code>：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'1 + 1 &lt;&gt; 3'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">const</span> b = <span class="hljs-number">1</span>;

  expect(a + b).not.toBe(<span class="hljs-number">3</span>);
});
</code></pre>
<p>对于一些特定的值，如<code>true</code>, <code>false</code>, <code>null</code>, <code>undefined</code>，我们可以使用特定的匹配器：</p>
<ul>
<li><code>toBeNull</code> - 只能匹配<code>null</code></li>
<li><code>toBeUndefined</code> - 只能匹配<code>undefined</code></li>
<li><code>toBeDefined</code> - 与<code>toBeUndefined</code>相反</li>
<li><code>toBeTruthy</code> - 匹配值为真的情况（与<code>if</code>语句判断真值的规则一样）</li>
<li><code>toBeFalsy</code> - 匹配值为假的情况（与<code>if</code>语句判断假值的规则一样）</li>
</ul>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'null'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> n = <span class="hljs-literal">null</span>;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test(<span class="hljs-string">'zero'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> z = <span class="hljs-number">0</span>;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
</code></pre>
<p><code>toMatch</code>允许我们使用正则表达式来验证字符串：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'测试代码以代码结尾'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  expect(<span class="hljs-string">'测试代码'</span>).toMatch(<span class="hljs-regexp">/代码$/</span>);
});
</code></pre>
<p>可以使用<code>toContain</code>来判断数组中是否包含指定的值：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'购物清单中包含了啤酒'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  expect([<span class="hljs-string">'剃须刀'</span>, <span class="hljs-string">'大米'</span>, <span class="hljs-string">'啤酒'</span>, <span class="hljs-string">'化妆品'</span>]).toContain(<span class="hljs-string">'啤酒'</span>);
});
</code></pre>
<p>可以使用<code>toThrow</code>来测试异常信息：</p>
<pre><code class="hljs css language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserInfo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'网络错误'</span>);
}

test(<span class="hljs-string">'因网络错误无法获取用户信息'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  expect(getUserInfo).toThrow();
  expect(getUserInfo).toThrow(<span class="hljs-built_in">Error</span>);
  expect(getUserInfo).toThrow(<span class="hljs-string">'网络错误'</span>);
  expect(getUserInfo).toThrow(<span class="hljs-regexp">/网络/</span>);
});
</code></pre>
<p>还有很多匹配器。查看<a href="https://jestjs.io/docs/en/expect">Jest Expect API</a>。</p>
<h2><a class="anchor" aria-hidden="true" id="测试异步代码"></a><a href="#测试异步代码" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试异步代码</h2>
<p>异步是前端编程经常遇到的场景。这里重点讲解一下如何使用 Jest 测试<code>Promise</code>和<code>async/await</code>。</p>
<p>我们可能想到测试异步的方式如下：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'获取数据失败'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  fetchData().catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> expect(e).toMatch(<span class="hljs-string">'error'</span>));
});
</code></pre>
<p>但是这样的测试是不正确的。我们需要告诉 jest 什么时候 promise 执行完成，我们可以使用<code>done</code>函数：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'获取数据失败'</span>, <span class="hljs-function">(<span class="hljs-params">done</span>) =&gt;</span> {
  fetchData().catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    expect(e).toMatch(<span class="hljs-string">'error'</span>);
    done();
  });
});
</code></pre>
<p>Jest 针对 promise 测试提供了一种更便捷的方式来代替<code>done</code>方式，即返回<code>promise</code>：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'获取数据失败'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> fetchData().catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> expect(e).toMatch(<span class="hljs-string">'error'</span>));
});
</code></pre>
<blockquote>
<p>使用 Jest 测试 promise 时必须返回<code>promise</code>。</p>
</blockquote>
<p>上面的例子如果<code>fetchData()</code>成功获取数据，则不会执行<code>catch()</code>的回调函数，也就不会执行<code>expect(e).toMatch('error')</code>。这不是我们期望的，我们可以使用<code>expect.assertions</code>来确保测试过程必须执行多少个断言：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'获取数据失败'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  epxect.assertions(<span class="hljs-number">1</span>); <span class="hljs-comment">// 必须有1个断言执行，</span>
  <span class="hljs-comment">// 也就是得有一个`expect`被执行。</span>

  <span class="hljs-keyword">return</span> fetchData().catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> expect(e).toMatch(<span class="hljs-string">'error'</span>));
});
</code></pre>
<p>我们可以使用<code>resolves/rejects</code>来进一步简化 promise 的测试：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'获取的数据是张三'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> epxect(fetchData(<span class="hljs-number">1</span>)).resolves.toBe(<span class="hljs-string">'张三'</span>);
});

test(<span class="hljs-string">'获取数据失败'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> expect(fetchData(<span class="hljs-string">'不存在的id'</span>)).rejects.toMatch(<span class="hljs-string">'error'</span>);
});
</code></pre>
<p>说到 Promise，就不得不说<code>async</code>和<code>await</code>。Jest 同样支持：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'获取的数据是张三'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  expect.assertions(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> epxect(fetchData(<span class="hljs-number">1</span>));
  expect(data).toBe(<span class="hljs-string">'张三'</span>);
});

test(<span class="hljs-string">'获取数据失败'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  expect.assertions(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> fetchData(<span class="hljs-string">'不存在的id'</span>);
  } <span class="hljs-keyword">catch</span> (e) {
    expect(e).toMatch(<span class="hljs-string">'error'</span>);
  }
});
</code></pre>
<p><code>async</code>和<code>await</code>与<code>.resolves</code>和<code>.rejects</code>的结合：</p>
<pre><code class="hljs css language-ts">test(<span class="hljs-string">'获取的数据是张三'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> epxect(fetchData(<span class="hljs-number">1</span>)).resolves.toBe(<span class="hljs-string">'张三'</span>);
});

test(<span class="hljs-string">'获取数据失败'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(fetchData(<span class="hljs-string">'不存在的id'</span>)).rejects.toThrow(<span class="hljs-string">'error'</span>);
});
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="setup-和-teardown"></a><a href="#setup-和-teardown" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>setup 和 teardown</h2>
<p>编写单元测试时，我们经常需要在测试前做一些准备工作，并在测试后进行一些整理工作，<code>Jest</code>提供辅助函数来处理这个问题。</p>
<h3><a class="anchor" aria-hidden="true" id="为多次测试重复设置"></a><a href="#为多次测试重复设置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为多次测试重复设置</h3>
<p>例如，我们考虑一些与城市信息数据库进行交互的测试。 你必须在每个测试之前调用方法 <code>initializeCityDatabase()</code> ，同时必须在每个测试后，调用方法 <code>clearCityDatabase()</code>。 你可以这样做：</p>
<pre><code class="hljs css language-js">beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  initializeCityDatabase();
});

afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  clearCityDatabase();
});

test(<span class="hljs-string">'city database has Vienna'</span>, () =&gt; {
  expect(isCity(<span class="hljs-string">'Vienna'</span>)).toBeTruthy();
});

test(<span class="hljs-string">'city database has San Juan'</span>, () =&gt; {
  expect(isCity(<span class="hljs-string">'San Juan'</span>)).toBeTruthy();
});
</code></pre>
<p><code>beforeEach</code> 和 <code>afterEach</code> 能够通过与<a href="https://jestjs.io/docs/zh-Hans/asynchronous">异步代码测试</a> 相同的方式处理异步代码 — — 他们可以采取 <code>done</code> 参数或返回一个 promise。 例如，如果 <code>initializeCityDatabase()</code> 返回解决数据库初始化时的 promise ，我们会想返回这一 promise︰</p>
<pre><code class="hljs css language-js">beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> initializeCityDatabase();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="一次性设置"></a><a href="#一次性设置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一次性设置</h3>
<p>在某些情况下，你只需要在文件的开头做一次设置。 当这种设置是异步行为时，可能非常恼人，你不太可能一行就解决它。 Jest 提供 <code>beforeAll</code> 和 <code>afterAll</code> 处理这种情况。</p>
<p>例如，如果 <code>initializeCityDatabase</code> 和 <code>clearCityDatabase</code> 都返回了 promise ，城市数据库可以在测试中重用，我们就能把我们的测试代码改成这样:</p>
<pre><code class="hljs css language-js">beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> initializeCityDatabase();
});

afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> clearCityDatabase();
});

test(<span class="hljs-string">'city database has Vienna'</span>, () =&gt; {
  expect(isCity(<span class="hljs-string">'Vienna'</span>)).toBeTruthy();
});

test(<span class="hljs-string">'city database has San Juan'</span>, () =&gt; {
  expect(isCity(<span class="hljs-string">'San Juan'</span>)).toBeTruthy();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="作用域"></a><a href="#作用域" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>作用域</h3>
<p>默认情况下，<code>before</code> 和 <code>after</code> 的块可以应用到文件中的每个测试。 此外可以通过 <code>describe</code> 块来将测试分组。 当 <code>before</code> 和 <code>after</code> 的块在 <code>describe</code> 块内部时，则其只适用于该 <code>describe</code> 块内的测试。</p>
<p>比如说，我们不仅有一个城市的数据库，还有一个食品数据库。我们可以为不同的测试做不同的设置︰</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">// Applies to all tests in this file</span>
beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> initializeCityDatabase();
});

test(<span class="hljs-string">'city database has Vienna'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  expect(isCity(<span class="hljs-string">'Vienna'</span>)).toBeTruthy();
});

test(<span class="hljs-string">'city database has San Juan'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  expect(isCity(<span class="hljs-string">'San Juan'</span>)).toBeTruthy();
});

describe(<span class="hljs-string">'matching cities to foods'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Applies only to tests in this describe block</span>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> initializeFoodDatabase();
  });

  test(<span class="hljs-string">'Vienna &lt;3 sausage'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    expect(isValidCityFoodPair(<span class="hljs-string">'Vienna'</span>, <span class="hljs-string">'Wiener Schnitzel'</span>)).toBe(<span class="hljs-literal">true</span>);
  });

  test(<span class="hljs-string">'San Juan &lt;3 plantains'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    expect(isValidCityFoodPair(<span class="hljs-string">'San Juan'</span>, <span class="hljs-string">'Mofongo'</span>)).toBe(<span class="hljs-literal">true</span>);
  });
});
</code></pre>
<p>注意：顶级的 beforeEach 在描述块内的 beforeEach 之前执行，以下的例子可以方便我们认识到执行的顺序。</p>
<pre><code class="hljs css language-ts">beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1 - beforeAll'</span>));
afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1 - afterAll'</span>));
beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1 - beforeEach'</span>));
afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1 - afterEach'</span>));
test(<span class="hljs-string">''</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1 - test'</span>));
describe(<span class="hljs-string">'Scoped / Nested block'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2 - beforeAll'</span>));
  afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2 - afterAll'</span>));
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2 - beforeEach'</span>));
  afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2 - afterEach'</span>));
  test(<span class="hljs-string">''</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2 - test'</span>));
});

<span class="hljs-comment">// 1 - beforeAll</span>
<span class="hljs-comment">// 1 - beforeEach</span>
<span class="hljs-comment">// 1 - test</span>
<span class="hljs-comment">// 1 - afterEach</span>
<span class="hljs-comment">// 2 - beforeAll</span>
<span class="hljs-comment">// 1 - beforeEach</span>
<span class="hljs-comment">// 2 - beforeEach</span>
<span class="hljs-comment">// 2 - test</span>
<span class="hljs-comment">// 2 - afterEach</span>
<span class="hljs-comment">// 1 - afterEach</span>
<span class="hljs-comment">// 2 - afterAll</span>
<span class="hljs-comment">// 1 - afterAll</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="describe-和-test-块的执行顺序"></a><a href="#describe-和-test-块的执行顺序" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>describe 和 test 块的执行顺序</h3>
<p>Jest 会在执行具体的 <code>test</code> 块之前执行所有的 <code>describe</code> 处理器部分。这也是为什么在 <code>before*</code> 和 <code>after*</code> 中做前后期准备，而不是在 <code>describe</code> 中的原因。一旦 <code>describe</code> 部分完成执行，随机顺序执行所有的测试。</p>
<pre><code class="hljs css language-ts">describe(<span class="hljs-string">'outer'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe outer-a'</span>);

  describe(<span class="hljs-string">'describe inner 1'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe inner 1'</span>);
    test(<span class="hljs-string">'test 1'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test for describe inner 1'</span>);
      expect(<span class="hljs-literal">true</span>).toEqual(<span class="hljs-literal">true</span>);
    });
  });

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe outer-b'</span>);

  test(<span class="hljs-string">'test 1'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test for describe outer'</span>);
    expect(<span class="hljs-literal">true</span>).toEqual(<span class="hljs-literal">true</span>);
  });

  describe(<span class="hljs-string">'describe inner 2'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe inner 2'</span>);
    test(<span class="hljs-string">'test for describe inner 2'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test for describe inner 2'</span>);
      expect(<span class="hljs-literal">false</span>).toEqual(<span class="hljs-literal">false</span>);
    });
  });

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe outer-c'</span>);
});

<span class="hljs-comment">// describe outer-a</span>
<span class="hljs-comment">// describe inner 1</span>
<span class="hljs-comment">// describe outer-b</span>
<span class="hljs-comment">// describe inner 2</span>
<span class="hljs-comment">// describe outer-c</span>
<span class="hljs-comment">// test for describe inner 1</span>
<span class="hljs-comment">// test for describe outer</span>
<span class="hljs-comment">// test for describe inner 2</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="建议"></a><a href="#建议" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>建议</h3>
<p>如果测试失败，第一件要检查的事就是，当仅运行这条测试时，它是否仍然失败。 在 Jest 中很容易地只运行一个测试 — — 只需暂时将 <code>test</code> 命令更改为 <code>test.only</code>:</p>
<pre><code class="hljs css language-js">test.only(<span class="hljs-string">'this will be the only test that runs'</span>, () =&gt; {
  expect(<span class="hljs-literal">true</span>).toBe(<span class="hljs-literal">false</span>);
});

test(<span class="hljs-string">'this test will not run'</span>, () =&gt; {
  expect(<span class="hljs-string">'A'</span>).toBe(<span class="hljs-string">'A'</span>);
});
</code></pre>
<p>如果你有一个测试，当它作为一个更大的用例中的一部分时，经常运行失败，但是当你单独运行它时，并不会失败，所以最好考虑其他测试对这个测试的影响。 通常可以通过修改 <code>beforeEach</code> 来清除一些共享的状态来修复这种问题。 如果不确定某些共享状态是否被修改，还可以尝试在 <code>beforeEach</code> 中 log 数据来 debug。</p>
<h2><a class="anchor" aria-hidden="true" id="模拟"></a><a href="#模拟" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模拟</h2>
<p>模拟函数通过屏蔽函数的实际实现来轻松实现测试代码之间的链接。比如你的代码需要请求 API 获取数据，但是执行单元测试时又无法保证有相应的服务器启动并可访问到。这时你就可以使用模拟函数，屏蔽掉真实 API 请求，而模拟其行为：如果你的测试预期请求真实 API 成功并返回数据，那么你就模拟这个行为，并返回数据。</p>
<p>模拟函数，可以捕获到对函数的调用（以及在这些调用中传递的参数），在使用 new 实例化时捕获构造函数的实例，并允许返回值的测试时配置（根据测试需要指定返回值）。</p>
<p>有两种方式来模拟函数：</p>
<ol>
<li>在测试代码级别上创建模拟函数</li>
<li>编写手工模拟来覆盖模块依赖</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="使用模拟函数"></a><a href="#使用模拟函数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用模拟函数</h3>
<blockquote>
<p>通过<code>jest.fn()</code>创建模拟函数。</p>
</blockquote>
<p>我们有一个<code>forEach</code>实现，会使用指定数组中的每一项挨个调用回调函数：</p>
<pre><code class="hljs css language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">items: T[], callback: (item: T) =&gt; <span class="hljs-built_in">void</span></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; items.length; index++) {
    callback(items[index]);
  }
}
</code></pre>
<p>为了测试这个函数，我们可以使用模拟函数，并且检查模拟状态以确保回调函数按照期望被执行了：</p>
<pre><code class="hljs css language-ts">it(<span class="hljs-string">'test forEach'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> mockCallback = jest.fn(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> <span class="hljs-number">42</span> + x);
  forEach([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], mockCallback);

  <span class="hljs-comment">// 模拟函数被调用了两次</span>
  expect(mockCallback.mock.calls.length).toBe(<span class="hljs-number">2</span>);

  <span class="hljs-comment">// 第一次调用的第一个参数是0</span>
  expect(mockCallback.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// 第二次调用的第一个参数是1</span>
  expect(mockCallback.mock.calls[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">1</span>);

  <span class="hljs-comment">// 第一次调用回调函数时返回值是42</span>
  expect(mockCallback.mock.results[<span class="hljs-number">0</span>].value).toBe(<span class="hljs-number">42</span>);
});
</code></pre>
<p>每一个模拟函数都有<code>.mock</code>属性，它会记录模拟函数调用和返回值情况。它的用法如上面的例子所示。</p>
<h3><a class="anchor" aria-hidden="true" id="mock-的返回值"></a><a href="#mock-的返回值" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mock 的返回值</h3>
<p>我们有个<code>map</code>实现，它会将一个数组的每一项调用回调函数，将回调函数的返回值组成一个新的数组：</p>
<pre><code class="hljs css language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">items: T[], callback: (item: T, index: <span class="hljs-built_in">number</span>) =&gt; U</span>): <span class="hljs-title">U</span>[] </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; items.length; index++) {
    result.push(callback(item[index], index));
  }
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>我们使用模拟函数作为回调函数来测试这个<code>map</code>：</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> callbackMock = jest.fn();

callbackMock
  .mockReturnValueOnce(<span class="hljs-number">10</span>)
  .mockReturnValueOnce(<span class="hljs-number">20</span>)
  .mockReturnValue(<span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> result = map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], callbackMock);

expect(callbackMock.mock.calls.length).toBe(<span class="hljs-number">4</span>);
expect(result).toEqual([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="模拟模块"></a><a href="#模拟模块" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模拟模块</h3>
<p>我们常常需要对外部依赖的模块进行模拟，才能快速有效地测试我们的代码。比如我们获取用户数据的方法用到了<a href="https://github.com/sinoui/http">@sinoui/http</a>：</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'@sinoui/http'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUsers</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> http.get(<span class="hljs-string">'/users.json'</span>);
}
</code></pre>
<p>现在为了不真的发送 API 请求而测试我们的代码，我们需要用到<code>jest.mock(...)</code>函数来自动模拟@sinoui/http 模块。备注：如果真的发送 API 请求来测试我们的代码，这样的测试是很慢的而且是脆弱的，一旦 API 停止服务或者网络访问不了了，那么测试就无法进行。</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'@sinoui/http'</span>;
<span class="hljs-keyword">import</span> getUsers <span class="hljs-keyword">from</span> <span class="hljs-string">'./users'</span>;

jest.mock(<span class="hljs-string">'@sinoui/http'</span>);

test(<span class="hljs-string">'获取用户数据'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> users = [{ name: <span class="hljs-string">'Jacking'</span> }];

  <span class="hljs-comment">// 模拟`http.get`的返回值为`Promise.resolve(uers)`。</span>
  http.get.mockResolvedValue(users);

  <span class="hljs-keyword">return</span> getUsers().then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> expect(result).toEqual(users));
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="模拟实现"></a><a href="#模拟实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模拟实现</h3>
<p>如果你需要模拟一个模块默认导出的函数，那么你需要用到<code>mockImplementation</code>：</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">// foo.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 实现代码</span>
};

<span class="hljs-comment">// test.js</span>
jest.mock(<span class="hljs-string">'../foo'</span>);
<span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../foo'</span>);

foo.mockImplementation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">42</span>);
foo();
<span class="hljs-comment">// &gt; 42</span>
</code></pre>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2019-7-19 by tianyanqiu</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/sinoui-guide/docs/git-standard"><span class="arrow-prev">← </span><span>git提交注释规范</span></a><a class="docs-next button" href="/sinoui-guide/docs/react-component-test-guide"><span>测试React组件</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#体验一下">体验一下</a></li><li><a href="#核心概念">核心概念</a></li><li><a href="#匹配器-matchers">匹配器 Matchers</a></li><li><a href="#测试异步代码">测试异步代码</a></li><li><a href="#setup-和-teardown">setup 和 teardown</a><ul class="toc-headings"><li><a href="#为多次测试重复设置">为多次测试重复设置</a></li><li><a href="#一次性设置">一次性设置</a></li><li><a href="#作用域">作用域</a></li><li><a href="#describe-和-test-块的执行顺序">describe 和 test 块的执行顺序</a></li><li><a href="#建议">建议</a></li></ul></li><li><a href="#模拟">模拟</a><ul class="toc-headings"><li><a href="#使用模拟函数">使用模拟函数</a></li><li><a href="#mock-的返回值">Mock 的返回值</a></li><li><a href="#模拟模块">模拟模块</a></li><li><a href="#模拟实现">模拟实现</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2019 sinosoft.com.cn</section></footer></div></body></html>